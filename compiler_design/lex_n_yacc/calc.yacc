%{
#include<stdio.h>

int regs[26];
int base;

%}

/*
%union:  specifies type for non-terminal. The types specified here, 
determine the type of values that will be used popped/put on the stack
during the parsing.
%token:   Specifes the terminals
%start:   Specifies the start non-terminal.
%type:    Specifies the types of various non-terminals. The types are chosen from the ones specified in %union.
*/

%start list

%union { int a; }

%type <a> expr number                                   //Only need to define for those non-terminals that are used in the semantic rule section.
%token <a> DIGIT LETTER                                 //All non-literal tokens must be defined here. The type may be omitted for those that aren't used in semantic rules.

/*
Defining the left associative tokens in the grammar. 
A token is left associative iff, out of various possible parse trees,
we choose the one in which the left-ward instance of the token appears lowest in the tree.
For, e.g. : a-b-c, is parsed as 
      exp                              exp
   /   |   \                         /  |  \
  exp  -   c       rather than      a   -   exp
 / | \                                     / | \
a  -  b                                    b -  c
if - is left associative.

The precendence and associativity will be automatically attached to the literal tokens.
The literals are listed in increasing order of precedence. 
All the literals on the same line have same precedence and associativity.
See : https://www.ibm.com/docs/en/zos/2.4.0?topic=section-precedence-in-grammar-rules
*/

%left '|'
%left '&'
%left '+' '-'
%left '*' '/' '%'
%left UMINUS                            /*supplies precedence for unary minus */

%%                                      /* beginning of rules section */

/*
1. By default, the first symbol of this section(list) 
   will be considered the start symbol. Use %start in 
   previous section to specify a custom start symbol.

2. $$ refers to the LHS of the current grammar rule.
   $i refers to the i-th symbol in the RHS of the current grammar rule.
*/

list:                       /*empty */
         |
        list stat '\n'
         |
        list error '\n'                        
         {
           /*
           The error state is reached when no other rule from those provided can be matched.
           Since last token is '\n'. Each line is parsed independently. The error in one line won't pass on to the error in next line.
           By default, the parser stays in error state for 3 more input tokens after matching this rule. 
           If the next line contains an error in the first three tokens, the parser deletes the tokens and does not produce a message
           (i.e., doesn't call the yyerror() routine). But, yyerrok; disables this action(by bringing parser back to normal state). 
           So, as soon as the parser detects error in next line, it reports it.
           */
           yyerrok;
         }
         ;
stat:    expr
         {
           printf("%d\n",$1);
         }
         |
         LETTER '=' expr
         {
           regs[$1] = $3;
         }

         ;

expr:    '(' expr ')'
         {
           $$ = $2;
         }
         |
         expr '*' expr
         {

           $$ = $1 * $3;
         }
         |
         expr '/' expr
         {
           $$ = $1 / $3;
         }
         |
         expr '%' expr
         {
           $$ = $1 % $3;
         }
         |
         expr '+' expr
         {
           $$ = $1 + $3;
         }
         |
         expr '-' expr
         {
           $$ = $1 - $3;
         }
         |
         expr '&' expr
         {
           $$ = $1 & $3;
         }
         |
         expr '|' expr
         {
           $$ = $1 | $3;
         }
         |

        '-' expr %prec UMINUS
         {
           /*
           This branch has same precendence as UMINUS. Branches are matched in order order 
           of their precendence. If one unique branch can be found at a higher level of precedence, 
           the branching having lower levels of precedence aren't checked. As soon as multiple branches,
           at the level being checked are found; syntax error will be generated.
           See: https://docs.oracle.com/cd/E19504-01/802-5880/6i9k05dh3/index.html
           */
           $$ = -$2;
         }
         |
         LETTER
         {
           $$ = regs[$1];
         }

         |
         number
         ;

number:  DIGIT
         {
           $$ = $1;
           base = ($1==0) ? 8 : 10;
         }       |
         number DIGIT
         {
           $$ = base * $1 + $2;
         }
         ;

%%
main()
{
 /*
 The yyparse() function is automatically generated by "yacc -d cacl.yacc" command
 in the y.tab.c file. It calls the yylex() function: which is generated by
 "lex calc.l" command in the lex.yy.c file. Each call to the yylex() function is supposed to 
 return return the next token from left to right.
 See: https://silcnitc.github.io/yacc.html#navexy0al
 */
 return(yyparse());
}

yyerror(s)
char *s;
{
  /*
  This is the first function that is called whenever the Error action is performed.
  After this function has be called, and the error action performed, the state is updated to
  the error state corresponding to the rule with the "error" keyword.
  */
  fprintf(stderr, "%s\n",s);
}

yywrap()
{
  /*
  This is called by lex when input is exhausted. When the end of the file is reached the 
  return value of yywrap() is checked. If it is non-zero, scanning terminates 
  and if it is 0 scanning continues with next input file.
  */
  return(1);
}